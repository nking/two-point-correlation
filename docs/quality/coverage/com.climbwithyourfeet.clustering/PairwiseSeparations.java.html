<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../.resources/report.css" type="text/css"/><link rel="shortcut icon" href="../.resources/report.gif" type="image/gif"/><title>PairwiseSeparations.java</title><link rel="stylesheet" href="../.resources/prettify.css" type="text/css"/><script type="text/javascript" src="../.resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../.sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">Jacoco Report</a> &gt; <a href="index.source.html" class="el_package">com.climbwithyourfeet.clustering</a> &gt; <span class="el_source">PairwiseSeparations.java</span></div><h1>PairwiseSeparations.java</h1><pre class="source lang-java linenums">package com.climbwithyourfeet.clustering;

import algorithms.connected.ConnectedValuesGroupFinder;
import algorithms.misc.MinMaxPeakFinder;
import algorithms.misc.MiscMath0;
import algorithms.misc.MiscSorter;
import algorithms.util.PixelHelper;
import algorithms.util.PolygonAndPointPlotter;
import gnu.trove.iterator.TIntIntIterator;
import gnu.trove.iterator.TIntIterator;
import gnu.trove.map.TIntIntMap;
import gnu.trove.map.TIntObjectMap;
import gnu.trove.map.hash.TIntIntHashMap;
import gnu.trove.map.hash.TIntObjectHashMap;
import gnu.trove.set.TIntSet;
import gnu.trove.set.hash.TIntHashSet;
import java.awt.image.BufferedImage;
import java.awt.image.WritableRaster;
import java.io.File;
import java.io.IOException;
import java.net.URL;
import java.util.Arrays;
import java.util.List;
import java.util.logging.Level;
import java.util.logging.Logger;
import javax.imageio.ImageIO;

/**
 *
 * @author nichole
 */
<span class="pc bpc" id="L32" title="1 of 2 branches missed.">public class PairwiseSeparations {</span>
    
<span class="fc" id="L34">    private boolean debug = false;</span>
    
<span class="fc" id="L36">    private final Logger log = Logger.getLogger(this.getClass().getName());</span>
    
    public void setToDebug() {
<span class="fc" id="L39">        debug = true;</span>
<span class="fc" id="L40">    }</span>

    public static class ScaledPoints {
        public TIntSet pixelIdxs;
        int width;
        int height;
        int xScale;
        int yScale;
    }
    
    public BackgroundSeparationHolder extract(TIntSet pixelIdxs, int width, 
        int height) {
        
<span class="pc bpc" id="L53" title="1 of 2 branches missed.">        if (pixelIdxs.size() &lt; 12) {</span>
<span class="nc" id="L54">            throw new IllegalArgumentException(</span>
                &quot;pixelIdxs.size must be 12 or more&quot;);
        }
        
        // these are the non-point distances to the points        
<span class="fc" id="L59">        int[][] dt = DistanceTransformUtil.transform(pixelIdxs, width, height);</span>
        
<span class="fc bfc" id="L61" title="All 2 branches covered.">        for (int i = 0; i &lt; dt.length; ++i) {</span>
<span class="fc bfc" id="L62" title="All 2 branches covered.">            for (int j = 0; j &lt; dt[i].length; ++j) {</span>
<span class="fc" id="L63">                int d = dt[i][j];</span>
<span class="fc bfc" id="L64" title="All 2 branches covered.">                if (d &gt; 0) {</span>
<span class="fc bfc" id="L65" title="All 2 branches covered.">                    if (d &gt; 2) {</span>
<span class="fc" id="L66">                        dt[i][j] = (int)Math.round(Math.sqrt(d));</span>
                    }
                }
            }
        }
        
        //printDT(dt);
        
        /*
        within dt 
           want to find the local maxima in which the surrounding points are
           all smaller in value.
        
           need to use a connected value group finder to gather the adjacent
              pixels w/ same values &gt; 0
        
           need to make an adjacency map of those groups.
        
           then will find which groups, that is values, are the maxima.
        
           the critical separation is the smallest of the maxima, but will
               want to look at the counts of that where possible.
        
        caveats:
           single group of points in center will have no maxima found as 
               described unless there are gaps in points in the cluster.
               if there are gaps,
                  that will be found.
               else the background separation will be found to be 1
        */
               
<span class="fc" id="L97">        PixelHelper ph = new PixelHelper();</span>
<span class="fc" id="L98">        int[] xy = new int[2];</span>
                
<span class="fc" id="L100">        ConnectedValuesGroupFinder finder = new ConnectedValuesGroupFinder();</span>
<span class="fc" id="L101">        finder.setMinimumNumberInCluster(1);</span>
<span class="fc" id="L102">        List&lt;TIntSet&gt; valueGroups = finder.findGroups(dt);</span>
     
<span class="fc" id="L104">        long ts = System.currentTimeMillis();</span>
        
<span class="fc bfc" id="L106" title="All 2 branches covered.">        if (debug) {</span>
<span class="fc" id="L107">            float[] x = new float[valueGroups.size()];</span>
<span class="fc" id="L108">            float[] y = new float[x.length];</span>
<span class="fc bfc" id="L109" title="All 2 branches covered.">            for (int i = 0; i &lt; valueGroups.size(); ++i) {</span>
<span class="fc" id="L110">                TIntSet group = valueGroups.get(i);</span>
<span class="fc" id="L111">                int tPix = group.iterator().next();</span>
<span class="fc" id="L112">                ph.toPixelCoords(tPix, width, xy);</span>
<span class="fc" id="L113">                int v = dt[xy[0]][xy[1]];</span>
<span class="fc" id="L114">                x[i] = v;</span>
<span class="fc" id="L115">                y[i] = group.size();</span>
            }
<span class="fc" id="L117">            float xMax = MiscMath0.findMax(x);</span>
<span class="fc" id="L118">            float yMin = MiscMath0.findMin(y);</span>
<span class="fc" id="L119">            float yMax = MiscMath0.findMax(y);</span>
            PolygonAndPointPlotter plotter;
            try {
<span class="fc" id="L122">                plotter = new PolygonAndPointPlotter();</span>
<span class="fc" id="L123">                plotter.addPlot(0, xMax, yMin, yMax, x, y, x, y,</span>
                    &quot;separation&quot;);
<span class="fc" id="L125">                plotter.writeFile(&quot;_separation_&quot; + ts);</span>
<span class="nc" id="L126">            } catch (IOException ex) {</span>
<span class="nc" id="L127">                Logger.getLogger(PairwiseSeparations.class.getName()).log(Level.SEVERE, null, ex);</span>
<span class="fc" id="L128">            }</span>
<span class="fc" id="L129">            Runtime.getRuntime().gc();</span>
        }
        
        // key = index of values Group, value = adjacent indexes of valuesGroup
<span class="fc" id="L133">        TIntObjectMap&lt;TIntSet&gt; adjMap = createAdjacencyMap(</span>
            valueGroups, width, height);

        // TODO: below here consider if aggregation of values within a tolerance
        // of similar values is needed.  The tolerance should depend upon the 
        // range of separations and on the value to be aggregated.
        //  ...such a correction can be done with kernel smoothing using 
        //     a kernel bandwidth fixed in the distance axis.
        //     if implemented with fast wavelet transforms, 
        //     the results are instead a K-Nearest Neighbors smoothing 
        //     unless the input is resampled to fixed spacing.

        // search for valueGroups which has value larger than all adj neighbors
        // key = valueGroups index, value = dt value for the group
<span class="fc" id="L147">        TIntIntMap groupMaximaIdxs = new TIntIntHashMap();</span>
        
        // key = value, value = count
<span class="fc" id="L150">        TIntIntMap valueCounts = new TIntIntHashMap();</span>
        
<span class="fc" id="L152">        int minMaxima = Integer.MAX_VALUE;</span>
        
<span class="fc bfc" id="L154" title="All 2 branches covered.">        for (int i = 0; i &lt; valueGroups.size(); ++i) {</span>
            
<span class="pc bpc" id="L156" title="1 of 2 branches missed.">            if (!adjMap.containsKey(i)) {</span>
<span class="nc" id="L157">                continue;</span>
            }
            
<span class="fc" id="L160">            TIntSet group = valueGroups.get(i);</span>
            
<span class="fc" id="L162">            int tPix = group.iterator().next();</span>
<span class="fc" id="L163">            ph.toPixelCoords(tPix, width, xy);</span>
<span class="fc" id="L164">            int v = dt[xy[0]][xy[1]];</span>
            
<span class="fc bfc" id="L166" title="All 2 branches covered.">            if (v == 0) {</span>
<span class="fc" id="L167">                continue;</span>
            }
            
            // if this is a boundary pixel and v &gt; 1, skip it
<span class="fc bfc" id="L171" title="All 10 branches covered.">            if (v &gt; 1 &amp;&amp; (xy[0] == 0 || xy[1] == 0 || (xy[0] == (width - 1)) ||</span>
                (xy[1] == (height - 1)))) {
<span class="fc" id="L173">                continue;</span>
            }
            
<span class="fc" id="L176">            boolean allAreLower = true;</span>
            
<span class="fc" id="L178">            TIntSet adj = adjMap.get(i);</span>
            
<span class="fc" id="L180">            TIntIterator iter2 = adj.iterator();</span>
<span class="fc bfc" id="L181" title="All 2 branches covered.">            while (iter2.hasNext()) {</span>
<span class="fc" id="L182">                int aIdx = iter2.next();</span>
<span class="fc" id="L183">                TIntSet group2 = valueGroups.get(aIdx);</span>
<span class="fc" id="L184">                int tPix2 = group2.iterator().next();</span>
<span class="fc" id="L185">                ph.toPixelCoords(tPix2, width, xy);</span>
<span class="fc" id="L186">                int v2 = dt[xy[0]][xy[1]];</span>
            
<span class="fc bfc" id="L188" title="All 2 branches covered.">                if (v2 &gt; v) {</span>
<span class="fc" id="L189">                    allAreLower = false;</span>
<span class="fc" id="L190">                    break;</span>
                }
<span class="fc" id="L192">            }</span>
            
<span class="fc bfc" id="L194" title="All 2 branches covered.">            if (allAreLower) {</span>
<span class="fc" id="L195">                groupMaximaIdxs.put(i, v);</span>
<span class="fc" id="L196">                int c = valueCounts.get(v);</span>
<span class="fc" id="L197">                valueCounts.put(v, c + group.size());</span>
                
<span class="fc bfc" id="L199" title="All 2 branches covered.">                if (v &lt; minMaxima) {</span>
<span class="fc" id="L200">                    minMaxima = v;</span>
                }
            }
        }
        
<span class="fc" id="L205">        adjMap = null;</span>
        
<span class="fc bfc" id="L207" title="All 2 branches covered.">        if (valueCounts.size() == 0) {</span>
            
            // this can happen when a convex filled point set is centered
            // in the range.  there will be no maxima in the &quot;void&quot;
            
<span class="fc" id="L212">            BackgroundSeparationHolder h = new BackgroundSeparationHolder();</span>
<span class="fc" id="L213">            h.setXYBackgroundSeparations(1, 1);</span>
<span class="fc" id="L214">            h.setTheThreeSeparations(new float[]{0, 1, 2});</span>
<span class="fc" id="L215">            h.setAndNormalizeCounts(new float[]{1, 1, 0});</span>

<span class="fc" id="L217">            return h;</span>
        }
        
        // look at frequency of groupMaximaIdxs values
<span class="fc" id="L221">        int[] maximaValues = new int[valueCounts.size()];</span>
<span class="fc" id="L222">        int[] maximaCounts = new int[valueCounts.size()];</span>
<span class="fc" id="L223">        TIntIntIterator iter = valueCounts.iterator();</span>
<span class="fc bfc" id="L224" title="All 2 branches covered.">        for (int i = 0; i &lt; valueCounts.size(); ++i) {</span>
<span class="fc" id="L225">            iter.advance();</span>
<span class="fc" id="L226">            maximaValues[i] = iter.key();</span>
<span class="fc" id="L227">            maximaCounts[i] = iter.value();</span>
        }
        
<span class="fc" id="L230">        MiscSorter.sortBy1stArg(maximaValues, maximaCounts);</span>
       
<span class="fc bfc" id="L232" title="All 2 branches covered.">        if (debug) {</span>
<span class="fc" id="L233">            int[] x = maximaValues;</span>
<span class="fc" id="L234">            int[] y = maximaCounts;</span>
<span class="fc" id="L235">            float xMax = MiscMath0.findMax(x);</span>
<span class="fc" id="L236">            float yMin = MiscMath0.findMin(y);</span>
<span class="fc" id="L237">            float yMax = MiscMath0.findMax(y);</span>
            PolygonAndPointPlotter plotter;
            try {
<span class="fc" id="L240">                plotter = new PolygonAndPointPlotter();</span>
<span class="fc" id="L241">                plotter.addPlot(0, xMax, yMin, yMax, x, y, x, y,</span>
                    &quot;max sep&quot;);
<span class="fc" id="L243">            plotter.writeFile(&quot;_separation_maxima_&quot; + ts);</span>
<span class="nc" id="L244">            } catch (IOException ex) {</span>
<span class="nc" id="L245">                Logger.getLogger(PairwiseSeparations.class.getName()).log(Level.SEVERE, null, ex);</span>
<span class="fc" id="L246">            }</span>
        }
     
        //float[] qs = MiscMath0.calcQuartiles(maximaCounts, true);
        //System.out.println(&quot;qs=&quot; + Arrays.toString(qs));
                
<span class="fc" id="L252">        MinMaxPeakFinder finder2 = new MinMaxPeakFinder();</span>
<span class="fc" id="L253">        float avgMin = finder2.calculateMeanOfSmallest(maximaCounts, 0.03f);</span>
        
        // minMaximaIdx is for the first peak in maximaCounts,
        // and firstZeroIdx is the first subsequent point that falls to approx 0
<span class="fc" id="L257">        int minMaximaIdx = -1;</span>
<span class="fc" id="L258">        int firstZeroIdx = -1;</span>
<span class="fc bfc" id="L259" title="All 2 branches covered.">        for (int i = 0; i &lt; maximaValues.length; ++i) {</span>
<span class="fc" id="L260">            int d = maximaValues[i];</span>
<span class="pc bpc" id="L261" title="1 of 4 branches missed.">            if (minMaximaIdx == -1 &amp;&amp; (d == minMaxima)) {</span>
<span class="fc" id="L262">                minMaximaIdx = i;</span>
            }
<span class="fc bfc" id="L264" title="All 2 branches covered.">            if (d &gt; minMaxima) {</span>
<span class="fc" id="L265">                int c = maximaCounts[i];</span>
<span class="fc bfc" id="L266" title="All 2 branches covered.">                if (c &lt;= avgMin) {</span>
<span class="fc" id="L267">                    firstZeroIdx = i;</span>
<span class="fc" id="L268">                    break;</span>
                }
            }
        }
        
<span class="pc bpc" id="L273" title="3 of 4 branches missed.">        assert(minMaximaIdx &gt; -1);</span>
        
<span class="fc bfc" id="L275" title="All 2 branches covered.">        if (firstZeroIdx == -1) {</span>
<span class="fc" id="L276">            firstZeroIdx = minMaximaIdx + 1;</span>
<span class="fc bfc" id="L277" title="All 2 branches covered.">            if (firstZeroIdx == maximaValues.length) {</span>
<span class="fc" id="L278">                firstZeroIdx = minMaximaIdx;</span>
            }
        }
        
<span class="fc bfc" id="L282" title="All 2 branches covered.">        if (firstZeroIdx &gt; minMaximaIdx) {</span>
<span class="fc" id="L283">            int maxCountIdx0 = -1;</span>
<span class="fc" id="L284">            int maxCount0 = Integer.MIN_VALUE;</span>
<span class="fc bfc" id="L285" title="All 2 branches covered.">            for (int i = 0; i &lt; firstZeroIdx; ++i) {</span>
<span class="fc bfc" id="L286" title="All 2 branches covered.">                if (maximaCounts[i] &gt; maxCount0) {</span>
<span class="fc" id="L287">                    maxCountIdx0 = i;</span>
<span class="fc" id="L288">                    maxCount0 = maximaCounts[i];</span>
                }
            }
<span class="fc" id="L291">            minMaximaIdx = maxCountIdx0;</span>
<span class="fc" id="L292">            minMaxima = maxCount0;</span>
        }
        
<span class="fc" id="L295">        System.out.println(&quot;found background separation=&quot; </span>
            + maximaValues[minMaximaIdx]);
        
<span class="fc" id="L298">        BackgroundSeparationHolder h = new BackgroundSeparationHolder();</span>
                
<span class="fc" id="L300">        int m2 = (int)Math.round(maximaValues[minMaximaIdx]/Math.sqrt(2));</span>
<span class="fc" id="L301">        h.setXYBackgroundSeparations(m2, m2);</span>
        
<span class="fc" id="L303">        h.setTheThreeSeparations(new float[]{</span>
            0, maximaValues[minMaximaIdx], 
            maximaValues[firstZeroIdx]});
        
<span class="fc" id="L307">        h.setAndNormalizeCounts(new float[]{</span>
            maximaCounts[minMaximaIdx], maximaCounts[minMaximaIdx], 
            maximaCounts[firstZeroIdx]});
       
<span class="fc" id="L311">        return h;</span>
    }
    
    public ScaledPoints scaleThePoints(TIntSet pixelIdxs, int width, int height) {
        
<span class="pc bpc" id="L316" title="1 of 2 branches missed.">        if (pixelIdxs.size() &lt; 12) {</span>
<span class="nc" id="L317">            throw new IllegalArgumentException(</span>
                &quot;pixelIdxs.size must be 12 or more&quot;);
        }
                
<span class="fc" id="L321">        ScaleFinder sf = new ScaleFinder();</span>
        
<span class="fc" id="L323">        int[] xyScales = sf.find(pixelIdxs, width, height);</span>
        
        TIntSet pixelIdxs2;
        int width2, height2;
<span class="pc bpc" id="L327" title="1 of 4 branches missed.">        if (xyScales[0] &lt;= 1 &amp;&amp; xyScales[1] &lt;= 1) {</span>
<span class="fc" id="L328">            pixelIdxs2 = new TIntHashSet(pixelIdxs);</span>
<span class="fc" id="L329">            width2 = width;</span>
<span class="fc" id="L330">            height2 = height;</span>
<span class="pc bpc" id="L331" title="3 of 4 branches missed.">        } else if (xyScales[0] &lt;= 1 &amp;&amp; xyScales[1] &gt; 1) {</span>
<span class="nc" id="L332">            pixelIdxs2 = new TIntHashSet(pixelIdxs.size());</span>
<span class="nc" id="L333">            width2 = width;</span>
<span class="nc" id="L334">            height2 = (int)Math.ceil((float)height/(float)xyScales[1]);            </span>
<span class="pc bpc" id="L335" title="2 of 4 branches missed.">        } else if (xyScales[0] &gt; 1 &amp;&amp; xyScales[1] &lt;= 1) {</span>
<span class="nc" id="L336">            pixelIdxs2 = new TIntHashSet(pixelIdxs.size());</span>
<span class="nc" id="L337">            width2 = (int)Math.ceil((float)width/(float)xyScales[0]);</span>
<span class="nc" id="L338">            height2 = height;</span>
        } else {
            // scale both axes
<span class="fc" id="L341">            pixelIdxs2 = new TIntHashSet(pixelIdxs.size());</span>
<span class="fc" id="L342">            width2 = (int)Math.ceil((float)width/(float)xyScales[0]);</span>
<span class="fc" id="L343">            height2 = (int)Math.ceil((float)height/(float)xyScales[1]);</span>
        }
        
<span class="fc bfc" id="L346" title="All 2 branches covered.">        if (pixelIdxs2.isEmpty()) {</span>
            
<span class="fc" id="L348">            PixelHelper ph = new PixelHelper();</span>
<span class="fc" id="L349">            int[] xy = new int[2];</span>
            
<span class="fc" id="L351">            TIntIterator iter = pixelIdxs.iterator();</span>
<span class="fc bfc" id="L352" title="All 2 branches covered.">            while (iter.hasNext()) {</span>
                
<span class="fc" id="L354">                int pixIsx = iter.next();</span>
                
<span class="fc" id="L356">                ph.toPixelCoords(pixIsx, width, xy);</span>
                
<span class="pc bpc" id="L358" title="1 of 2 branches missed.">                if (xyScales[0] &gt; 1) {</span>
<span class="fc" id="L359">                    xy[0] /= xyScales[0];</span>
                }
<span class="pc bpc" id="L361" title="1 of 2 branches missed.">                if (xyScales[1] &gt; 1) {</span>
<span class="fc" id="L362">                    xy[1] /= xyScales[1];</span>
                }
                
<span class="fc" id="L365">                int pixIdx2 = ph.toPixelIndex(xy[0], xy[1], width2);</span>
                
<span class="fc" id="L367">                pixelIdxs2.add(pixIdx2);</span>
<span class="fc" id="L368">            }</span>
        }
        
<span class="fc" id="L371">        ScaledPoints sp = new ScaledPoints();</span>
<span class="fc" id="L372">        sp.pixelIdxs = pixelIdxs2;</span>
<span class="fc" id="L373">        sp.width = width2;</span>
<span class="fc" id="L374">        sp.height = height2;</span>
<span class="fc" id="L375">        sp.xScale = xyScales[0];</span>
<span class="fc" id="L376">        sp.yScale = xyScales[1];</span>
    
<span class="fc" id="L378">        return sp;</span>
    }
    
    private TIntObjectMap&lt;TIntSet&gt; createAdjacencyMap(
        List&lt;TIntSet&gt; groupList, int width, int height) {
        
<span class="fc" id="L384">        TIntIntMap pixGroupMap = new TIntIntHashMap();</span>
<span class="fc bfc" id="L385" title="All 2 branches covered.">        for (int i = 0; i &lt; groupList.size(); ++i) {</span>
<span class="fc" id="L386">            TIntSet group = groupList.get(i);</span>
<span class="fc" id="L387">            TIntIterator iter = group.iterator();</span>
<span class="fc bfc" id="L388" title="All 2 branches covered.">            while (iter.hasNext()) {</span>
<span class="fc" id="L389">                int pixIdx = iter.next();</span>
<span class="pc bpc" id="L390" title="3 of 4 branches missed.">                assert(!pixGroupMap.containsKey(pixIdx));</span>
<span class="fc" id="L391">                pixGroupMap.put(pixIdx, i);</span>
<span class="fc" id="L392">            }</span>
        }
        
<span class="fc" id="L395">        PixelHelper ph = new PixelHelper();</span>
<span class="fc" id="L396">        int[] dx8 = new int[]{-1, -1,  0,  1, 1, 1, 0, -1};</span>
<span class="fc" id="L397">        int[] dy8 = new int[]{ 0, -1, -1, -1, 0, 1, 1,  1};</span>
        
<span class="fc" id="L399">        int[] xy = new int[2];</span>
        
<span class="fc" id="L401">        int nBSLen = groupList.size();</span>
        
<span class="fc" id="L403">        System.out.println(&quot;nBSLen=&quot; + nBSLen);</span>
        
<span class="fc" id="L405">        TIntObjectMap&lt;TIntSet&gt; adjMap = new TIntObjectHashMap&lt;TIntSet&gt;();</span>
        
<span class="fc bfc" id="L407" title="All 2 branches covered.">        for (int i = 0; i &lt; groupList.size(); ++i) {</span>
<span class="fc" id="L408">            TIntSet group = groupList.get(i);</span>
<span class="fc" id="L409">            TIntIterator iter = group.iterator();</span>
<span class="fc" id="L410">            TIntSet adj = adjMap.get(i);</span>
            
<span class="fc bfc" id="L412" title="All 2 branches covered.">            while (iter.hasNext()) {</span>
<span class="fc" id="L413">                int pixIdx = iter.next();</span>
<span class="fc" id="L414">                ph.toPixelCoords(pixIdx, width, xy);</span>
                
<span class="fc bfc" id="L416" title="All 2 branches covered.">                for (int k = 0; k &lt; dx8.length; ++k) {</span>
<span class="fc" id="L417">                    int vX = xy[0] + dx8[k];</span>
<span class="fc" id="L418">                    int vY = xy[1] + dy8[k];</span>
<span class="fc bfc" id="L419" title="All 8 branches covered.">                    if (vX &lt; 0 || vY &lt; 0 || vX &gt;= width || vY &gt;= height) {</span>
<span class="fc" id="L420">                        continue;</span>
                    }
<span class="fc" id="L422">                    int pixIdx2 = ph.toPixelIndex(vX, vY, width);</span>
                    
<span class="pc bpc" id="L424" title="1 of 2 branches missed.">                    if (!pixGroupMap.containsKey(pixIdx2)) {</span>
<span class="nc" id="L425">                        continue;</span>
                    }
                    
<span class="fc" id="L428">                    int j = pixGroupMap.get(pixIdx2);</span>
                    
<span class="fc bfc" id="L430" title="All 2 branches covered.">                    if (i == j) {</span>
<span class="fc" id="L431">                        continue;</span>
                    }
                    
<span class="fc bfc" id="L434" title="All 2 branches covered.">                    if (adj == null) {</span>
<span class="fc" id="L435">                        adj = new TIntHashSet();</span>
<span class="fc" id="L436">                        adjMap.put(i, adj);</span>
                    }
<span class="fc" id="L438">                    adj.add(j);</span>
                }
<span class="fc" id="L440">            }</span>
        }
        
<span class="fc" id="L443">        return adjMap;</span>
    }
    
    private void writeDebugImage(double[][] dt, String fileSuffix, int width, 
        int height) throws IOException {

<span class="nc" id="L449">        BufferedImage outputImage = new BufferedImage(width, height,</span>
            BufferedImage.TYPE_BYTE_GRAY);

<span class="nc" id="L452">        WritableRaster raster = outputImage.getRaster();</span>

<span class="nc bnc" id="L454" title="All 2 branches missed.">        for (int i = 0; i &lt; dt.length; ++i) {</span>
<span class="nc bnc" id="L455" title="All 2 branches missed.">            for (int j = 0; j &lt; dt[0].length; ++j) {</span>
<span class="nc" id="L456">                int v = (int)Math.round(dt[i][j]);</span>
<span class="nc" id="L457">                raster.setSample(i, j, 0, v);</span>
            }
        }

        // write to an output directory.  we have user.dir from system properties
        // but no other knowledge of users's directory structure
<span class="nc" id="L463">        URL baseDirURL = this.getClass().getClassLoader().getResource(&quot;.&quot;);</span>
<span class="nc" id="L464">        String baseDir = null;</span>
<span class="nc bnc" id="L465" title="All 2 branches missed.">        if (baseDirURL != null) {</span>
<span class="nc" id="L466">            baseDir = baseDirURL.getPath();</span>
        } else {
<span class="nc" id="L468">            baseDir = System.getProperty(&quot;user.dir&quot;);</span>
        }
<span class="nc bnc" id="L470" title="All 2 branches missed.">        if (baseDir == null) {</span>
<span class="nc" id="L471">            return;</span>
        }
<span class="nc" id="L473">        File t = new File(baseDir + &quot;/bin&quot;);</span>
<span class="nc bnc" id="L474" title="All 2 branches missed.">        if (t.exists()) {</span>
<span class="nc" id="L475">            baseDir = t.getPath();</span>
<span class="nc bnc" id="L476" title="All 2 branches missed.">        } else if ((new File(baseDir + &quot;/target&quot;)).exists()) {</span>
<span class="nc" id="L477">            baseDir = baseDir + &quot;/target&quot;;</span>
        }

        // no longer need to use file.separator
<span class="nc" id="L481">        String outFilePath = baseDir + &quot;/&quot; + fileSuffix + &quot;.png&quot;;</span>

<span class="nc" id="L483">        ImageIO.write(outputImage, &quot;PNG&quot;, new File(outFilePath));</span>

<span class="nc" id="L485">        Logger.getLogger(this.getClass().getName()).info(&quot;wrote &quot; + outFilePath);</span>
<span class="nc" id="L486">    }</span>
   
    private static void printDT(int[][] dt) {
        
<span class="nc" id="L490">        int w = dt.length;</span>
<span class="nc" id="L491">        int h = dt[0].length;</span>
        
<span class="nc" id="L493">        StringBuilder sb2 = new StringBuilder();</span>
<span class="nc bnc" id="L494" title="All 2 branches missed.">        for (int j = 0; j &lt; h; ++j) {</span>
<span class="nc" id="L495">            sb2.append(&quot;row &quot;).append(j).append(&quot;: &quot;);</span>
<span class="nc bnc" id="L496" title="All 2 branches missed.">            for (int i = 0; i &lt; w; ++i) {</span>
<span class="nc" id="L497">                int v = dt[i][j];</span>
<span class="nc bnc" id="L498" title="All 2 branches missed.">                if (v &gt; (Integer.MAX_VALUE - 3)) {</span>
<span class="nc" id="L499">                    sb2.append(String.format(&quot; ---&quot;));</span>
                } else {
<span class="nc" id="L501">                    sb2.append(String.format(&quot; %3d&quot;, v));</span>
                }
            }
<span class="nc" id="L504">            sb2.append(&quot;\n&quot;);</span>
        }
<span class="nc" id="L506">        System.out.println(sb2.toString());</span>
<span class="nc" id="L507">    }</span>
    
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.eclemma.org/jacoco">JaCoCo</a> 0.7.5.201505241946</span></div></body></html>